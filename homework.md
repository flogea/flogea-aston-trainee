# Логвинова Катя

###### Homework 1

---

#### Подробно прочитать про метод запроса OPTIONS - и кратко его описать, когда вызывается, где используется, что передает и принимает.

> **OPTIONS** – используется для описания параметров соединения с сервером.

Метод _OPTIONS_ позволяет клиенту узнать, какие опции доступны для ресурса на сервере. Этот запрос не изменяет состояние ресурса и используется для проверки доступности и настройки CORS (Cross-Origin Resource Sharing).

#### `Пример использования метода options:`

```javascript
axios
  .options('/api/users/1', {
    headers: {
      'Access-Control-Allow-Origin': '*',
    },
  })
  .then((response) => {
    console.log(response);
  })
  .catch((error) => {
    console.log(error);
  });
```

---

#### Прочитать и описать ключевые особенности "HTTP" Версии `3.0`

- **HTTP/3** — готовящаяся к стандартизации версия протокола HTTP. Её главное отличие от предыдущих версий в том, что она использует новый транспортный протокол QUIC и передаёт данные быстрее.

- **QUIC** — транспортный протокол, работающий поверх UDP. Передаёт данные быстрее TCP, тратит меньше времени на установку соединения, но при этом такой же надёжный.

- HTTP/3 использует QUIC на транспортном уровне и уровне безопасности. QUIC заменяет TCP и TLS.

- Помимо QUIC, HTTP/3 отличается от HTTP/2 тем, что имеет другой алгоритм сжатия заголовков и исключает некоторые функции (например, мультиплексирование), так как их уже содержит QUIC.

- HTTP/3 лучше реализовывает мультиплексирование. Если в HTTP/2 при потере TCP-пакета вся передача данных останавливалась до восстановления пропажи, то в HTTP/3 информация продолжает передаваться.

- В использовании HTTP/3 пока есть некоторые сложности, связанные с определением типа протокола клиентом и сервером и блокировкой UDP-пакетов некоторыми брандмауэрами. Но эти проблемы решатся, когда веб перейдёт на новый протокол.

- Пока HTTP/3 не стандартизован, но его уже поддерживают многие сервисы и браузеры, в том числе EdgeCDN

---

#### Прочитать про способы отмены запроса, включая объект "AbortController"

Для прерывания метода fetch существует специальный встроенный объект: AbortController, который можно использовать для отмены не только fetch, но и других асинхронных задач. Он имеет единственный метод abort() и единственное свойство signal.

> **AbortController** – масштабируемый, он позволяет отменить несколько вызовов fetch одновременно.

---

#### Написать по 2 примера создания примитивных значений (если есть несколько способов - использовать) (string, number, boolean, null, undefined, symbol, bigInt)

1. String:

```javascript
   const str1 = 'Hello World';
   const str2 = "Hello World";
   const str3 = \`Hello World`;
```

2. Number:

```javascript
const num1 = 42;
const num2 = 3.14;
const num3 = NaN;
const num4 = Infinity;
```

3. Boolean:

```javascript
const bool1 = true;
const bool2 = false;
```

4. Null:

```javascript
const nullValue = null;
```

5. Undefined:

```javascript
let undefinedValue;
```

6. Symbol:

```javascript
const symbol1 = Symbol('id');
const symbol2 = Symbol();
```

7. BigInt:

```javascript
const bigInt1 = 9007199254740991n;
const bigInt2 = BigInt('9007199254740991');
```

---

#### Почему, если обратиться к переменным созданным через let, const до их объявления - мы получаем ReferenceError?

let и const имеют блочную область видимость, т.е. они видны только после объявления или в определенном блоке кода. В отличие от var (в котором если мы вызовем переменную до объявления и получим undefined), значение этих переменных находятся в мертвой зоне, вследствие чего возникает ошибка ReferenceError.

---

#### Решить:

```javascript
const res = 'B' + 'a' + (1 - 'hello');
console.log(res); // BaNaN
```

```javascript
const res2 = (true && 3) + 'd';
console.log(res2); // 3d
```

```javascript
const res3 = Boolean(true && 3) + 'd';
console.log(res3); // trued
```
